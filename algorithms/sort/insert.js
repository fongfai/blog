/* 
现在，我们来看点稍微复杂的东西。我这里还是有三个问题要问你。
第一，插入排序是原地排序算法吗？
从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。
第二，插入排序是稳定的排序算法吗？
在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
第三，插入排序的时间复杂度是多少？
如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为O(n)。注意，这里是从尾到头遍历已经有序的数据。
如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为O(n2)。
还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，所以平均时间复杂度为O(n2)。
 */
function insertionSort2(a, n) {
  if (n <= 1) return;

  for (var i = 1; i < n; ++i) {
    var value = a[i];
    var j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
          console.log('arr1', a, 'i:' +i , 'j:'+j, 'a[i]:' + a[i], 'a[j]:'+ a[j], 'value:', value)
        a[j+1] = a[j];  // 数据移动
           console.log('arr2', a)
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}


insertionSort2([4, 5, 6, 1, 3, 2], 6)